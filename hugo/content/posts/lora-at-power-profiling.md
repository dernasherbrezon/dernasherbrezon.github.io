---
title: "Тестирование потребления энергии в lora-at"
date: 2023-11-25T23:28:18+01:00
draft: true
chartjs: true
tags:
  - lora
  - lora-at
  - esp32
  - esp-idf
---

Как следует разобравшись с тем, [как работает Power Profiler Kit 2 (PPK2)]({{< ref "/power-profiler-kit2" >}}), я решил протестировать разные режимы работы. На самом деле [lora-at](https://github.com/dernasherbrezon/lora-at) - не такое уж и простое приложение. Тут и работа с bluetooth, и работа с чипом sx127x, и обработка команд с UART шины. Есть, где развернуться.

## Методология измерений

Измерять пиковое потребление тока, наверное, не очень полезно в контексте микроконтроллеров: оно вряд ли выйдет за границы 500мА. Тут скорее нужно измерять силу тока во времени, так как некоторые процессы протекают быстро и потребляют много энергии, а некоторые - медленно и потребляют мало энергии. Потраченная энергия за время измеряется в Ач, либо, в случае с PPK2, мКл. Кулон (Кл) — это величина заряда, прошедшего через сечение проводника при силе тока 1 А за время 1 с. PPK2 интегрирует график по времени и может очень быстро отображать потраченный заряд за выбранный интервал.

Прям чувствуется атмосфера лабы по физике.

Помимо этого, потребление тока зависит от конкретной платы и скорости работы микроконтроллера. Во всех тестах я использовал [Heltec LoRa 32 v2](https://resource.heltec.cn/download/WiFi_LoRa_32/WIFI_LoRa_32_V2.pdf), который работал на частоте 80Мгц.

Помимо этого, PPK2 сэмплирует со скоростью 100Кгц, что генерирует достаточно большое количество данных. Все эти точки невозможно отобразить на графике, поэтому зачастую я брал среднее за некоторый интервал. Это, конечно же, влияет на точность измерений.

## sx127x

Начать, пожалуй, лучше всего с самого основного - чипа sx127x. Библиотека [sx127x]({{< ref "/posts/sx127x" >}}) позволяет достаточно гибко конфигурировать режимы работы, скорость передачи и получения данных, разные усилители мощности. В итоге параметров, влияющих на потребление энергии, получается прилично. Я постарался их сгруппировать в категории удобные для анализа. 

#### Получение данных

Для тестирования приёмника, я настроил второй модуль, который отправляет короткое сообщение:

```
AT+LORATX=CAFE,433200012,125000,9,5,18,10,8,4,0,0,1,0
```

А измеряемый модуль принимает:

```
AT+LORARX=433200012,125000,9,5,18,10,8,4,0,0,1,0
```

После чего, то же самое для FSK модуляции:

```
AT+FSKTX=CAFE,433200012,4800,5000,4,12AD,0,2,1,4,0,0
```

И приём:

```
AT+FSKRX=433200012,4800,5000,4,12AD,0,2,1,4,5000,20000
```

В итоге получился следующий график:

{{< chartjs url="/static/img/lora-at-power-profiling/fsk-vs-lora.json" id="fskVsLora" title="Сравнение FSK и LoRa" datasource="fsk2bytes" datasourceLabel="FSK" datasource2="lora2bytes" datasource2Label="LoRa" yAxisLabel="Ток" yAxisUnit="мA" xAxis="time" xAxisLabel="Время" xAxisUnit="мс" staticSrc="/img/smart-usb-meter-a3-b/razernaga2.png" >}}

На нём видно, что:

 * LoRa гораздо быстрее обрабатывает сообщение: 13.6мс против 19мс
 * Более энергоэффектиное. Опять же счёт скорости обработки общее потребление было 511мкКл против 775мкКл
 * Пиковое потребление чуть ниже

На самом деле такое сравнение некорректно. Потребление энергии напрямую зависит от скорости передачи данных. Чем выше скорость, тем быстрее обрабатывается сообщение и меньше тратится энергии.

#### CAD режим

В sx127x есть специальный режим, который называется CAD (Channel Activity Detection). Он используется для оптимизации энергопотребления приёмника. Идея заключается в следующем:

 * приёмник включается на полную мощность на определённое время
 * после чего переходит в режим пониженного энергопотребления и пытается проанализировать полученный сигнал
 * если обнаружена преамбула пакета, то чип генерирует прерывание и можно переключаться в обычным режим приёма
 * если преамбула не обнаружена, то чип выжидает некоторое время в режиме низкого энергопотребления и возвращается к шагу 1
 
{{< svg "/img/lora-at-power-profiling/1.svg" >}}

Согласно спецификации потребление может уменьшаться чуть ли не в два раза:

<table>
<thead>
  <tr>
    <th>Bandwidth (kHz)</th>
    <th>Full Rx, IDDR_L (mA)</th>
    <th>Processing, IDDC_L (mA)</th>
  </tr>	
</thead>
<tbody>
  <tr>
    <td>7.8 to 41.7</td>
    <td>11</td>
    <td>5.2</td>
  </tr>	
  <tr>
    <td>62.5</td>
    <td>11</td>
    <td>5.6</td>
  </tr>	
  <tr>
    <td>125</td>
    <td>11.5</td>
    <td>6</td>
  </tr>	
  <tr>
    <td>250</td>
    <td>12.4</td>
    <td>6.8</td>
  </tr>	
  <tr>
    <td>500</td>
    <td>13.8</td>
    <td>8.3</td>
  </tr>	
</tbody>
</table>

Запустить приём в CAD режиме можно следующей командой:

```
AT+LORACADRX=433200012,125000,9,5,18,10,8,4,0,0,1,0
```

В итоге мне удалось получить:

{{< chartjs url="/static/img/lora-at-power-profiling/cad.json" id="cad" title="Сравнение обычного и CAD режимов" datasource="cad" datasourceLabel="CAD режим" datasource2="normal" datasource2Label="Обычный режим" yAxisLabel="Ток" yAxisUnit="мA" xAxis="time" xAxisLabel="Время" xAxisUnit="мс" staticSrc="/img/smart-usb-meter-a3-b/razernaga2.png" >}}

Тут сходу видно несколько интересных вещей:

 * Почему-то потребление тока в режиме поиска преамбулы чуть больше, чем в обычном режиме
 * Разница между активным режимом и пассивным ~6мА, что действительно похоже на правду при 125кГц
 * После выхода из CAD режима и перед переходом обратно проходит примерно 2мс. Это время, нужное ESP32, чтобы обработать прерывание и опять перейти в CAD режим. Поскольку CAD режим заканчивается тем, что переходит в STANDBY режим, потребление энергии существенно ниже. 2мс на обработку прерывания - это очень много. Если в это время начнётся передача сообщения, то приёмник может пропустить его начало. Контрольная сумма не совпадёт и всё сообщение не будет принято. С другой стороны, на практике всё работает отлично.

Если сравнивать энергопотребление, то CAD режим всё-таки более эффективный:

 * Потраченый заряд 1.41mC против 1.52mC за 40мс
 * Средний ток 35.27мА против 37.85мА

#### Отправка данных

Сначала я решил померить зависимость потребления от скорости передачи данных в FSK режиме. Я отправлял сообщение длиной 255 байт, уровнем мощности 4dbm и менял лишь скорость. Вот пример команды, которую я использовал:

```
AT+FSKTX=000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfe,433200012,1200,5000,4,12AD,0,2,1,4,240,0
```

{{< chartjs url="/static/img/lora-at-power-profiling/fsk-baud.json" id="fskBaud" title="Зависимость потребления энергии от скорости передачи" 
datasource="latencyMs" 
datasourceLabel="Время" 
yAxisLogarithmic="true"
yAxisLabel="Время"
yAxisUnit="мс"
datasource2="chargemC" 
datasource2Label="Потраченный заряд" 
y2AxisLogarithmic="true"
y2AxisLabel="Заряд" 
y2AxisUnit="мКл"
xAxis="baud" 
xAxisLabel="Baud"
xAxisUnit="" staticSrc="/img/smart-usb-meter-a3-b/razernaga2.png" >}}

На графике видна однозначная зависимость. Чем больше скорость передачи, тем меньше тратится энергии. Кстати, график к районе 76800 бод не всегда был такой. Когда я впервые замерил скорость, оказалось, что она в два раза меньше, чем при 38400 бод. И увеличение скорости вообще никак не влияло на потребление. Немного повозившись, я нашёл багу в коде. При чтении из UART происходило переполнение uint16_t и устанавливалась гораздо меньшая скорость. Упс!

С передачей в режиме LoRa всё гораздо сложнее. На скорость могут влиять: bandwidth, spreading factor и coding rate. Например, последний контролирует сколько бит используется для кодов коррекции ошибок. Чем больше, тем надёжнее передача, но при этом дольше передаются данные.

Я передавал те же 255 байт с уровнем мощности 4dbm, что и в FSK. Изменялись лишь ширина канала и spreading factor.

```
AT+LORATX=000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfe,433200012,500000,6,5,18,8,0,1,0,255,4,240,0
```

{{< chartjs url="/static/img/lora-at-power-profiling/lora-bandwidth-sf.json" id="loraBandwidthSf" title="Зависимость потребления энергии от Bandwidth и Spreading Factor" 
datasource2="sf6" datasource2Label="sf6" 
datasource3="sf7" datasource3Label="sf7" 
datasource4="sf8" datasource4Label="sf8" 
datasource5="sf9" datasource5Label="sf9" 
datasource6="sf10" datasource6Label="sf10" 
datasource7="sf11" datasource7Label="sf11" 
datasource="sf12" datasourceLabel="sf12" 
yAxisLabel="Потраченный заряд" yAxisUnit="мКл" 
xAxis="bandwidth" xAxisLabel="Bandwidth" xAxisUnit="Гц" staticSrc="/img/smart-usb-meter-a3-b/razernaga2.png" >}}

Небольшой анализ результатов:

 * Чем больше spreading factor, тем дольше передаётся сообщение и тем больше тратится энергии
 * Самая быстрая передача данных в LoRa (коэффициент 6 и ширина канала 500Кгц) тратит энергии больше, чем самая быстрая передача FSK (скорость 300Кбод)

В следующем тесте я сделал наоборот: зафиксировал скорость передачи данных и менял выходную мощность от -4 до 20.

```
AT+LORATX=CA,433200012,125000,9,5,18,8,0,1,1,0,-4,240,0
AT+LORATX=CA,433200012,125000,9,5,18,8,0,1,1,0,-3,240,0
...
AT+LORATX=CA,433200012,125000,9,5,18,8,0,1,1,0,17,240,1
AT+LORATX=CA,433200012,125000,9,5,18,8,0,1,1,0,20,240,1
```

{{< chartjs url="/static/img/lora-at-power-profiling/lora-power.json" id="loraPower" title="Зависимость потребления энергии от уровня мощности" 
datasource="avgCurrent" 
datasourceLabel="Средний ток" 
yAxisLabel="Средний ток"
yAxisUnit="мА"
datasource2="charge" 
datasource2Label="Потраченный заряд" 
y2AxisLabel="Заряд" 
y2AxisUnit="мКл"
xAxis="level" 
xAxisLabel="Уровень"
xAxisUnit="" staticSrc="/img/smart-usb-meter-a3-b/razernaga2.png" >}}

Интересно, почему при более высоком уровне мощности графики начинают пересекаться? Я передавал абсолютно одинаковое сообщение с одинаковыми параметрами. Время на передачу было одного и то же. Значит потраченный заряд должен линейно зависить от тока. Но вместо этого зависимость нелинейная.

Кстати, при 7dbm потребление тока достаточно ровное. А вот при 10 уже нет. Шумит внутренний усилитель мощности?

{{< chartjs url="/static/img/lora-at-power-profiling/txnoise.json" id="txNoise" title="7dbm и 10dbm" datasource="7dbm" datasourceLabel="7dbm" datasource2="10dbm" datasource2Label="10dbm" yAxisLabel="Ток" yAxisUnit="мA" xAxis="time" xAxisLabel="Время" xAxisUnit="" staticSrc="/img/smart-usb-meter-a3-b/razernaga2.png" >}}

Помимо разных уровней мощности, в чипе есть три разных физических пина, к которым может подключаться антенна: RFO_LF, RFO_HF и PA_BOOST. +20dbm может передаваться только по PA_BOOST. Но если передавать +7dbm, то есть ли разница какой пин использовать?

```
AT+LORATX=CA,168000012,125000,9,5,18,8,0,1,1,0,7,240,0
AT+LORATX=CA,433200012,125000,9,5,18,8,0,1,1,0,7,240,0
AT+LORATX=CA,433200012,125000,9,5,18,8,0,1,1,0,7,240,1
```

{{< chartjs url="/static/img/lora-at-power-profiling/txpin.json" id="txpin" title="Зависимость уровня потребления тока от пина" datasource="lf7dbm" datasourceLabel="RFO_LF" datasource2="hf7dbm" datasource2Label="RFO_HF" datasource3="boost7dbm" datasource3Label="PA_BOOST" yAxisLabel="Ток" yAxisUnit="мA" xAxis="time" xAxisLabel="Время" xAxisUnit="" staticSrc="/img/smart-usb-meter-a3-b/razernaga2.png" >}}

Да, разница есть.

 * Если сравнивать RFO_LF и RFO_HF, то видно, что потребление тока на частоте 168Мгц выше. Видимо, на этих частотах антенна [не согласована](https://ru.wikipedia.org/wiki/Коэффициент_стоячей_волны) больше.
 * Потребление тока при передаче через отдельный усилитель мощности и PA_BOOST пин больше, чем при передаче через RFO_HF. Наверное, разница уходит на питание того самого усилителя. 

#### Токовая защита усилителя

В чипе есть защита усилителя от превышения выходящего тока. При этом приговариваются слова про батарею, химические компоненты и пиковое потребление тока. К сожалению, поначалу я ничего не понял. Немного почитав теорию, стало чуть более понятно. Усилитель рассчитан на импеданс антенны 50Ом. Если импеданс не совпадает, либо перестал совпадать (антенна заржавела), то для генерации заданного уровня мощности, будет тратится всё больше и больше тока. Это может привести к тому, что усилитель может перегореть. Я сравнил отправку сообщения: без защиты (240мА), с небольшим ограничением (140мА), с максимальным ограничением (45мА).

```
AT+LORATX=CA,140200012,125000,9,5,18,8,0,1,1,0,17,240,1
AT+LORATX=CA,140200012,125000,9,5,18,8,0,1,1,0,17,140,1
AT+LORATX=CA,140200012,125000,9,5,18,8,0,1,1,0,17,45,1
```

{{< chartjs url="/static/img/lora-at-power-profiling/ocp2.json" id="ocp2" title="Токовая защита усилителя" datasource="ocp240" datasourceLabel="240мА" datasource2="ocp140" datasource2Label="140мА" datasource3="ocp45" datasource3Label="45мА" yAxisLabel="Ток" yAxisUnit="мA" xAxis="time" xAxisLabel="Время" xAxisUnit="" staticSrc="/img/smart-usb-meter-a3-b/razernaga2.png" >}}

Плата потребляет постоянное количество тока независимо от установленной защиты. Но это не значит, что защита не работает. Возможно, нужно измерять фактическую передаваемую мощность на антенне. К сожалению, у меня нет нужного оборудования, чтобы это проверить.

### Сравнение с C++ версией

Как я уже писал, [lora-at](https://github.com/dernasherbrezon/lora-at) изначально была реализована на C++ с помощью библиотек разного уровня качества. Моя теория заключалась в том, что переписав проект на С, я бы смог достичь более высокой эффективности и простоты. Одна из целей была достигнута - сборка проекта стала занимать меньше времени и размер прошивки уменьшился в два раза. Но что насчёт энергопотребления?

Работа чипа sx127x не зависит от выбранного языка, а вот время на подключение по Bluetooth, потребление тока в режиме ожидания и переход в спящий режим теоретически могут отличаться.

#### Подключение по Bluetooth

Одно из основных отличий первой версии lora-at от второй является работа с Bluetooth. Если в первой версии использовалась С++ библиотека поверх Bluedroid, то во второй версии я использовал Nimble. В документации сказано, что Nimble - это более легковесная реализация BLE протокола. Но так ли это на самом деле? И есть ли разница в скорости работы? Это очень легко проверить. Для этого можно использовать команду:

```
AT+BLUETOOTH=B8:27:EB:6C:7C:F8
```

Эта команда сделает следующее:

 * запустит подключение к bluetooth серверу по адресу ```B8:27:EB:6C:7C:F8```
 * выполнит поиск нужного GATT сервиса и характеристики

Для того, чтобы отловить момент начала и завершения, я сконфигурировал опцию:

```
CONFIG_BLUETOOTH_POWER_PROFILING=17
```

17-ый пин будет в состоянии "1" во время подключения и его можно использовать, чтобы сопоставить график PPK2 с потребляемой энергией.

{{< chartjs url="/static/img/lora-at-power-profiling/ble.json" id="bluetooth2" title="Потребление тока при подключении к Bluetooth серверу" datasource="blec" datasourceLabel="С" datasource2="blecpp" datasource2Label="С++" datasource3="blec2" datasource3Label="С около RPi" yAxisLabel="Ток" yAxisUnit="мA" xAxis="time" xAxisLabel="Время" xAxisUnit="мс" staticSrc="/img/smart-usb-meter-a3-b/razernaga2.png" >}}

 * Чем ближе к bluetooth серверу, тем быстрее происходит подключение
 * С код с расстояния в ~3 метра потратил 386.8мКл, С++ с расстояния в 1 метр - 308.3мКл. А С код с того же расстояния - 150.2мКл

Так себе получился тест, потому что нельзя однозначно сравнить разные подходы.

#### Цикл режима глубокого сна

Режим глубокого сна имеет смысл делать в цикле. Устройство засыпает на некоторое время, после чего просыпается, делает полезную работу и опять уходит в сон. Чем меньше активная фаза, тем меньше энергии будет потреблять устройство в конечном итоге.

///TODO


#### Обработка прерываний UART

Каждое нажатие клавиши вызывает прерывание, которое обрабатывает введённый символ. Сильно увеличенный график выглядит следующим образом:

{{< chartjs url="/static/img/lora-at-power-profiling/ppk-20231126T100310.json" id="uartSymbol2" title="Потребление тока при передаче символа" datasource="uartSymbol" datasourceLabel="Ток" yAxisLabel="Ток" yAxisUnit="мA" xAxis="time" xAxisLabel="Время" xAxisUnit="мс" staticSrc="/img/smart-usb-meter-a3-b/razernaga2.png" >}}

 * Каждое нажатие вызывает скачок потребления тока примерно на 10мА и длится примерно 1.4мс
 * Не очень понятно откуда два скачка
 * Если положить в буфер сразу несколько символов с помощью CMD+V, то это сгенерирует одно прерывание и очень похожий график

Если за 1.4мс потрачено 37.32мкКл и в режиме простоя за 1.4мс тратится 35.11мкКл, то нажатие на кнопку обошлось в 2.21мкКл. 

#### Работа на пониженной частоте

ESP32 может работать как на частоте 240Мгц, так и на 80Мгц. Очевидно, это уменьшает потребление энергии, за счёт более медленной работы. Но куда нам спешить, когда SPI шина работает на частоте 3Мгц?

<table>
<thead>
	<tr>
		<th>Режим работы</th>
		<th>Среднее потребление тока (C)</th>
		<th>Среднее потребление тока (C++)</th>		
	</tr>
</thead>
<tbody>
	<tr>
		<td>240Мгц</td>
		<td>48.27</td>
		<td>73.36</td>
	</tr>
	<tr>
		<td>160Мгц</td>
		<td>35.81</td>
		<td>50.64</td>
	</tr>
	<tr>
		<td>80Мгц</td>
		<td>27мА</td>
		<td>36.5мА</td>
	</tr>
</tbody>
</table>