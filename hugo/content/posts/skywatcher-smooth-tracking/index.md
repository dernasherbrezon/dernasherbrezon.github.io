---
title: "Точное управление антенной с помощью SkyWatcher Allview"
date: 2024-09-18T20:01:18+01:00
draft: false
chartjs: true
tags:
  - поворотное устройство
  - спутники
---

Немного повозившись с [протоколом]({{< ref "skywatcher-direct" >}}) [SkyWatcher Allview]({{< ref "products/skywatcher-allview" >}}), я понял, что алгоритм управления поворотным устройством можно улучшить. [В текущем виде]({{< ref "rotator-for-r2cloud" >}}) он выглядит следующим образом:

 * Каждую секунду 
 * Рассчитывается положение спутника относительно текущей позиции
 * Если оно отличается от предыдущего на заданную дельту (по-умолчанию 5°), то
 * Отправляется команда на поворотное устройство с новыми координатами

Этот алгоритм достаточно простой и надёжный, но непонятно 5° - это минимальная ошибка или максимальная? А можно ли придумать такой алгоритм, который наводил бы антенну с точностью меньше одного градуса?

## Тестирование

Прежде, чем делать более лучший алгоритм, нужно доказать, что он действительно лучший. А для этого нужно померить. В моём случае я измерял ошибку позиционирования моторов относительно положения спутника. Для этого я придумал следующее:

 * Выбрать пролёт одного спутника и эмулировать его в реальном времени
 * Запустить алгоритм и контролировать поворотное устройство
 * На соседнем потоке раз в 100мс опрашивать позиции моторов и сохранять в файл вместе с текущим временем. 100мс - это в 10 раз больше периода расчёта алгоритма - достаточно, чтобы увидеть задержки протокола и прочие артефакты
 * По завершению работы взять время и рассчитать позицию спутника
 * Посчитать разницу между позицией мотора и предполагаемой позицией спутника
 
## Текущий алгоритм

Для начала я прогнал текущий алгоритм.

{{< chartjs csv="img/old.csv" id="oldAz" title="Ошибка азимута" datasource="oldAz" datasourceLabel="Ошибка" yAxisLabel="Ошибка" yAxisUnit="°" staticSrc="img/oldAz.png">}}

Невероятно большая ошибка в середине из-за того, что поддерживаемый азимут в hamlib сконфигурирован от 0° до 360°. Поэтому вместо того, чтобы двигаться в обратную сторону от 0° до 359.99°, мотор начинается двигаться по часовой стрелке и делает почти полный круг.

{{< chartjs csv="img/old.csv" id="oldEl" title="Ошибка угла" datasource="oldEl" datasourceLabel="Ошибка" yAxisLabel="Ошибка" yAxisUnit="°" staticSrc="img/oldEl.png">}}

С ошибкой угла (elevation) всё выглядит чуть лучше. Она ожидаемо плавает от 0° до чуть больше 5°. Этот небольшой выход за пределы объясняется тем, что в зените угловая скорость максимальна, поэтому пока алгоритм примет решение о движении, спутник пролетает некоторое расстояние.

## Точное управление

Основная идея заключается в том, что моторы SkyWatcher Allview постоянно двигаются с некоторой заданной скоростью и таким образом постоянно направляют антенну на спутник. При этом во время пролёта над станцией угловая скорость меняется, поэтому весь интервал нужно разбить на небольшие отрезки, на которых моторы двигаются с разной скоростью.

SkyWatcher Allview позволяет задавать скорость моторов с точностью до секунд дуги в секунду (arcsec/sec), но протокол Hamlib это не поддерживает. Поэтому я решил подключаться к последовательному порту и отправлять команды [напрямую из Java](https://github.com/dernasherbrezon/r2cloud/blob/master/src/test/java/ru/r2cloud/rotator/allview/AllviewClient.java).

Помимо разной скорости, нужно ещё учитывать:

 * задержки в протоколе между моторами и компьютером. Оба мотора управляются через один провод. Это значит, что один мотор всегда будет получать команды чуть позже и всегда отставать.
 * SkyWatcher Allview работает в двух режимах: медленный и быстрый. Чтобы поменять скорость в медленном режиме достаточно лишь отправить новую скорость. А чтобы поменять скорость в быстром режиме, нужно остановить моторы и убедиться, что они остановились, выставить новую скорость и заново запустить моторы. А это несколько команд, каждая из которых добавляет задержку.
 * смена направления движения требует полной остановки моторов

{{< chartjs csv="img/rc1.csv" id="azRc1" title="Ошибка" datasource="azRc1" datasourceLabel="Азимут" datasource2="elRc1" datasource2Label="Угол" yAxisLabel="Ошибка" yAxisUnit="°" staticSrc="img/azRc1.png">}}

Первая версия показывает достаточно хорошие результаты. По крайней мере нет безумного вращения на 360°. Тем не менее, ошибка достаточно большая. Она особенно сильно накапливается, когда спутник подлетает к зениту. Это связано с тем, что я задаю скорость движения, а не абсолютное значение угла. 

Чтобы это побороть, я стал добавил следующее условие: если мотор в быстром режиме, то считывать текущий угол, а не брать из предыдущего расчёта.

{{< chartjs csv="img/rc3.csv" id="rc3" title="Ошибка" datasource="newAzFinal" datasourceLabel="Азимут" datasource2="newElFinal" datasource2Label="Угол"  yAxisLabel="Ошибка" yAxisUnit="°" staticSrc="img/rc3.png">}}

Результат стал значительно лучше.

Далее я решил попробовать компенсировать задержку в протоколе. Во-первых, положение мотора, которое я считываю каждые 100мс на самом деле устаревает на половину roundtrip. Во-вторых, позицию спутника можно рассчитать не через одну секунду, а через секунду и половину roundtrip.

{{< chartjs csv="img/rc3.csv" id="azRc2" title="Ошибка азимута в сравнении с предыдущей версией" datasource="newAzFinal" datasourceLabel="Первая версия" datasource2="azRc2" datasource2Label="Вторая версия"  yAxisLabel="Ошибка" yAxisUnit="°" staticSrc="img/azRc2.png">}}

{{< chartjs csv="img/rc3.csv" id="elRc22" title="Ошибка угла в сравнении с предыдущей версией" datasource="newElFinal" datasourceLabel="Первая версия" datasource2="elRc2" datasource2Label="Вторая версия"  yAxisLabel="Ошибка" yAxisUnit="°" staticSrc="img/elRc22.png">}}

Визуально не сильно изменилось.

## Бонус: влияние TLE

Раз уж я решил плотно заняться точностью наведения антенны, почему бы не померить влияние TLE. Чем старше TLE, тем они менее точные. Но насколько менее точные? Для этого я:

 * нашёл ближайший пролёт спутника
 * посчитал азимут и угол на каждом 10-секундном интервале. Это будут эталонные позиции. 
 * а потом [посчитал позицию спутника](https://github.com/dernasherbrezon/r2cloud/blob/master/src/test/java/ru/r2cloud/CalculateAzElErrorForStaleTle.java) для всё более и более старых TLE и вычел их из эталонной

Результат получился следующий:

{{< chartjs csv="img/diff.csv" id="tleAz" title="Ошибка азимута" datasource="az1" datasourceLabel="T-1" datasource2="az3" datasource2Label="T-3" datasource3="az7" datasource3Label="T-7" datasource4="az9" datasource4Label="T-9" datasource5="az19" datasource5Label="T-19" yAxisLabel="Ошибка" yAxisUnit="°" staticSrc="img/tleAz.png">}}

{{< chartjs csv="img/diff.csv" id="tleEl" title="Ошибка угла" datasource="el1" datasourceLabel="T-1" datasource2="el3" datasource2Label="T-3" datasource3="el7" datasource3Label="T-7" datasource4="el9" datasource4Label="T-9" datasource5="el19" datasource5Label="T-19" yAxisLabel="Ошибка" yAxisUnit="°" staticSrc="img/tleEl.png">}}

На графике видно, что TLE трёхдневной давности дают ошибку всего лишь в ~2°. Такая точностью вполне подходит для большинства спутников. Но уже T-7 (TLE полученные 7 дней назад) дают около 15°, что может сильно повлиять на приём сигнала.

## Заключение

В результате всех оптимизаций мне действительно удалось придумать алгоритм, который управляет антенной с точностью до градуса. Даже для пролётов около зенита - самый сложный участок для AzEl моторов. 

Но с другой стороны, чтобы внедрить этот алгоритм в r2cloud, нужно расширить протокол hamlib и учитывать особенности каждого мотора. На практике - это достаточно хлопотно и ценность сомнительна. Точность в 5° достаточна для большинства спутников. Например, [Discovery Dish](https://www.crowdsupply.com/krakenrf/discovery-dish) диаметром 70см можно наводить с точностью в ~18°, чтобы принять сигнал на частоте 1.6Ггц.


