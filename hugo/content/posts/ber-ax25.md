---
title: "Расчёт вероятности ошибки для AX.25"
date: 2022-02-19T22:13:18+00:00
draft: false
chartjs: true
tags:
  - radio
  - fsk
  - ber
---

## Введение

Обычно [вероятность ошибки](https://en.wikipedia.org/wiki/Bit_error_rate) используется для сравнения различных типов модуляции между собой. Однако, на практике помимо демодулятора используются дополнительные блоки:

 * формирование фреймов [канального уровня](https://ru.wikipedia.org/wiki/Канальный_уровень)
 * [контроль и коррекция ошибок](https://ru.wikipedia.org/wiki/Контроль_ошибок#Упреждающая_коррекция_ошибок)

И каждый из этих блоков может как уменьшить вероятность декодирования фрейма, так и увеличить. Все алгоритмы контроля и коррекции ошибок предназначены для того, чтобы увеличить вероятность декодирования фрейма. А вот формирование самих фреймов может сильно повлиять на возможности получения данных. 

Одним из самых распространённых протоколов канального уровня является HDLC. Также он используется в стеке AX.25, который в свою очередь используется в большинстве кубсатов для связи с наземными станциями. Увеличение количества принимаемых данных из космоса - одна из основных задач моего проекта [r2cloud](https://github.com/dernasherbrezon/r2cloud), поэтому мне интересно было померить насколько AX.25 хорош.

## Описание стенда

Итак, для того, чтобы посчитать количество ошибочно принятых бит, я создал класс [Ax25G3ruhBer](https://github.com/dernasherbrezon/jradio/blob/master/src/test/java/ru/r2cloud/jradio/Ax25G3ruhBer.java). Он работает следующим образом:

 * для каждого Eb/No
 * сгенерировать паузу, равную ```sampleRate / 8```. Во время паузы в демодулятор будет приходить только [белый гауссовский шум](https://ru.wikipedia.org/wiki/Аддитивный_белый_гауссовский_шум).
 * сформировать фрейм, смодулировать его в GMSK сигнал
 * добавить к GMSK сигналу шум
 * сгенерировать шум и полезный сигнал для оставшихся 99 фреймов.
 * пропустить полученный сигнал через демодулятор
 * посчитать количество успешных бит из общего количество переданных бит. 
 
Этот алгоритм значительно проще, чем [алгоритм вычисления ошибки для FSK]({{< ref "/jradio-ber-fsk" >}}), так как количество переданных и полученных бит легко посчитать.

## Результаты

Результаты представлены на графике ниже. Я так же добавил теоретический минимум FSK модуляции. Так как AX.25 зачастую используется поверх FSK модуляции и в нём нет блоков коррекции ошибок, то его теоретический минимум не может быть меньше минимума FSK.

{{< chartjs url="/static/img/ber-ax25/ber-ax25.json" id="ax25Ber" title="AX.25 BER" 
	datasource="fskBer" datasourceLabel="FSK" 
	datasource2="ax25Byte20Checksum" datasource2Label="Length 20 Checksum"
	datasource3="ax25Byte20NoChecksum" datasource3Label="Length 20 No Checksum" 
	datasource4="ax25Byte131Checksum" datasource4Label="Length 131 Checksum" 
	datasource5="ax25Byte131NoChecksum" datasource5Label="Length 131 No Checksum" 
	yAxisLabel="Bit Error Rate" yAxisUnit="" yMax="1" yAxisLogarithmic="true" yMaxTicksLimit="10" xAxis="ebno" xAxisLabel="Eb/No" xAxisUnit="dB" xMaxTicksLimit="11" staticSrc="/img/ber-ax25/ber-ax25.png" >}}

## Анализ

Многие графики обрываются. Это может значить несколько вещей: 

 * Либо не было проведено достаточно симуляций, чтобы получить статистически значимых результатов
 * Либо ошибки в тесте. AX.25 не может быть лучше теоретического предела FSK модуляции
 
BER кривая FSK вычислялась по формуле. Её результат записывался во float, поэтому очень маленькие значения просто округлились до 0. Это объясняет, почему жёлтая кривая обрывается.

Опыты, в которых была проверка контрольной суммы, при низком уровне сигнала совсем не декодируются, а начиная с какого-то значения декодируются все. Это вполне объяснимо, так как ошибка даже в одном бите детектируется контрольной суммой и весь фрейм отбрасывается. При этом опыты, в которых проверка контрольной суммы отключена, показывают плавное уменьшение количества ошибок. Это вполне ожидаемо и как раз показывает, что демодулятор распознаёт фреймы, но они отбрасываются из-за ошибок контрольной суммы.

Ещё интересный и очевидный факт - количество декодируемых фреймов зависит от их длины. Для длины в 20 байт минимальный уровень сигнала должен быть 9дБ, а для 131 байт - 11дБ. 131 байт я взял не случайно, а вычислил на основе средней длины AX.25 фрейма всех поддерживаемых спутников в [jradio](https://github.com/dernasherbrezon/jradio).

Резкий переход между ни одним полученным фреймом и всеми полученными фреймами, мне показался достаточно странным. Я попробовал построить спектограмму сигнала для первых 10 фреймов:

![](/img/ber-ax25/simulation.png)

Оказывается, шум на самом деле не настоящий. Вернее он настоящий, но из-за того, что блок генерации шума стартует всегда с одного и того же seed, получается, что шум повторяется через какие-то интервалы. Это как раз видно на спектограмме - повторяющиеся паттерны:

![](/img/ber-ax25/simulation2.png)

## Результаты 2

Я решил провести ещё раз опыт на основе полученных результатов со следующими модификациями:

 * выбрать разный начальный seed псевдослучайного генератора
 * добавить 3 байта преамбулы - 0xAA для того, чтобы синхронизировать демодулятор и скрэмблер
 
{{< chartjs url="/static/img/ber-ax25/ber-ax25-2.json" id="ax25Ber2" title="AX.25 BER" 
	datasource="fskBer" datasourceLabel="FSK" 
	datasource2="ax25Byte20Checksum" datasource2Label="Length 20 Checksum"
	datasource3="ax25Byte20NoChecksum" datasource3Label="Length 20 No Checksum" 
	datasource4="ax25Byte131Checksum" datasource4Label="Length 131 Checksum" 
	datasource5="ax25Byte131NoChecksum" datasource5Label="Length 131 No Checksum" 
	yAxisLabel="Bit Error Rate" yAxisUnit="" yMax="1" yAxisLogarithmic="true" yMaxTicksLimit="10" xAxis="ebno" xAxisLabel="Eb/No" xAxisUnit="dB" xMaxTicksLimit="11" staticSrc="/img/ber-ax25/ber-ax25-2.png" >}}
	
## Анализ 2


 * графики ожидаемо хуже теоретического минимума FSK модуляции.
 * При Eb/N0=13дБ фреймы лучше не декодируются. 
 * размер фрейма перестал влиять на результаты. 

Судя по результатам теста, демодулятор работает не так как ожидается. При полном отсутствии шума, все фреймы должны были декодироваться, ну или большая их часть. А в моём случае совсем наоборот. Очевидно, что ошибка где-то в демодуляторе. Я его проверил несколько раз, и потенциальным местом может быть [ClockRecoveryMM](https://github.com/dernasherbrezon/jradio/blob/master/src/main/java/ru/r2cloud/jradio/blocks/ClockRecoveryMM.java). Судя по отзывам в Интернете, он плохо работает при достаточно сильном (большая амплитуда) прямоугольном (форма) сигнале. А при Eb/N0=17дБ, это как раз и происходит. 

Возможно, мне следует:

 * посмотреть на альтернативные алгоритмы синхронизации сэмплов
 * попробовать искать AX.25 фреймы с помощью синхрослова
 