---
title: "Расчёт вероятности ошибки для BPSK демодулятора"
date: 2019-08-16T10:22:18+01:00
draft: false
cover: /img/jradio-ber-bpsk/ber-bpsk-demodulator.png
tags:
  - bpsk
  - ber
  - gnuradio
  - radio
---

## Введение

Спустя несколько недель я наконец-то закончил одну очень важную задачу - расчёт вероятности ошибки в BSPK демодуляторе. Почему это важно? Демодулятор работает с сигналом, который проходит через физическую среду. В этой среде возможны сильные или слабые возмущения, которые непосредственно влияют на сигнал. И принимаемый сигнал может меняться со временем от хорошего до плохого и обратно. Из-за этого нельзя однозначно сказать демодулятор "работает" или "не работает". Чтобы оценить его эффективность, необходимо симулировать среду передачи данных и сказать сколько ошибок он выдаёт при разных возмущениях среды. После этого уже можно сравнивать с теоретическими значениями и делать выводы.

## Описание теста

Для того чтобы симулировать поведение демодулятора, я написал специальный тест. За основу я взял идею [Daniel Estevez](https://destevez.net/2017/07/ber-simulation-in-gnu-radio/) и [реализовал её](https://github.com/dernasherbrezon/jradio/blob/master/src/test/java/ru/r2cloud/jradio/demod/BpskDemodulatorBer.java) на java.

Идея заключается в том, что подавая на вход BSPK модулятора множество "1", необходимо получить множество "1" на выходе демодулятора. Если в результате получается "0", то это значит ошибка. Если подсчитать количество "0" на выходе и поделить на общее количество полученных битов, то получится вероятность ошибки (BER).

К сожалению, просто передавать "1" и получать "1" не получится. Необходимо сделать несколько шагов:

 - сначала все генерируемые биты необходимо скрэмблировать. Это делается для того, чтобы в передаваемом сигнале было примерно одинаковое количество "0" и "1". Почему это важно? Дело в том, что демодулятор должен выполнить синхронизацию символов. Если в передаваемом сигнале будут только "1", то ему будет сложно принять решение сколько символов пришло "1111" или "11111". Если же в принимаемом сигнале будет вперемешку "0" и "1", то сигнал будет достаточно сильно меняться по фазе. И это сильно поможет при синхронизации символов.
 - далее биты необходимо дифференциально закодировать. Это значит, что необходимо передавать "1", только если сигнал сменился с "0" на "1" или с "1" на "0". Для чего? Приёмник может начать принимать сигнал в противофазе. В итоге все полученные биты будут инвертированы относительно оригинального сигнала. Однако, если передавать информацию через изменение битов, то после дифференциального декодирования информация восстановится без ошибок.
 - генерация BPSK сигнала. Для генерации сигнала и приёма используется согласующий Root Raised Cosine фильтр.
 - симуляция физического канала передачи данных. Здесь происходит самое интересное. По сути, эта симуляция - математическая модель, описывающая возмущения физической среды. С помощью неё можно симулировать фазовые, частотные и амплитудные колебания, добавить белый гауссовский шум, добавить различные начальные смещения. В моей симуляции я использовал только белый гауссовский шум, чтобы можно было сравнить с [теоретическим расчётом]({{< ref "/ber-bpsk" >}}).
 - демодуляция BPSK сигнала. Собственно, блок, который я собираюсь тестировать.
 - дифференциальное декодирование и дескрэмблирование.
 
На выходе я должен получить поток битов, на основе которых можно посчитать вероятность ошибки. Тут, правда, есть ещё несколько интересных моментов, которые стоит упомянуть. Во-первых, необходимо отбросить какое-то количество бит в самом начале. Они могут быть заведомо ошибочными, из-за начальной синхронизации демодулятора и дескремблера. Во-вторых, количество действительно неправильных бит должно быть поделено на 6. Это прежде всего связано с дифференциальным кодированием и скрэмблированием. 

Если была принята ошибка, то дифференциальное декодирование добавит ещё одну. Это значит необходимо поделить на 2. Для скремблирования я использую полином ```0b00000000000100001```. А это значит, что на любую ошибку на входе, будет сгенерировано 3 ошибки на выходе. Итого получается 2*3=6.

## Результаты

Прежде чем получить финальный результат, я провёл несколько измерений для различных конфигураций демодулятора. Изначально демодулятор содержал блок эквалайзера. Он был нужен прежде всего для того, чтобы бороться с [многолучевым распространением](https://ru.wikipedia.org/wiki/Многолучевое_распространение). Однако, на практике характеристики демодулятора сильно хуже теоретических:

[![](/img/jradio-ber-bpsk/lmsdd.png)](/img/jradio-ber-bpsk/lmsdd.m)

Синей линией обозначается теоретическое значение, красной - практическое измерение.

Ещё одним фактором влияющим на результат является количество данных. Вот пример расчёта для 100000 переданных битов:

[![](/img/jradio-ber-bpsk/100000bit.png)](/img/jradio-ber-bpsk/100000bit.m)

А вот тот же расчёт, но для 1000000 бит:

[![bpsk demodulator](/img/jradio-ber-bpsk/ber-bpsk-demodulator.png)](/img/jradio-ber-bpsk/ber-bpsk-demodulator.m)

Как видно на картинке, практическая реализация BPSK демодулятора почти совпадает с [теоретическими расчётами]({{< ref "/ber-bpsk" >}}). Это даёт уверенности в текущей реализации и позволяет начать оптимизировать другие показатели демодулятора. Также я могу в любой момент запустить тест и проверить изменились ли характеристики. Это очень мощный инструмент отладки. 

## Что дальше?

Можно добавить различные искажения среды и измерить реакцию демодулятора на них. Из того, что доступно:

 1. Симуляция многолучевого распространения.
 2. Симуляция частотных и фазовых колебаний.
 
Ещё одной важной характеристикой является скорость захвата несущей. Допустим изначально сигнал смещён на некоторую частоту. Это может возникнуть из-за неточного генератора сигнала в rtl-sdr или генератора сигнала самого спутника. В таком случае демодулятор должен уметь подстраиваться и компенсировать разницу частот. На эту подстройку должно уходить время. Было бы неплохо измерить его, и, возможно, улучшить.