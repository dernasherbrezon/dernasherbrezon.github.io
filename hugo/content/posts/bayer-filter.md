---
title: "Практическое применение фильтра Байера"
date: 2023-10-15T13:50:17+01:00
draft: false
compareImages: true
tags:
  - java
  - спутники
---

## Введение

Недавно я обнаружил, что спутник [RoseyCubesat-1](https://db.satnogs.org/satellite/LLCB-4532-4867-8038-3417) отправляет изображения из космоса и, конечно же, мне захотелось их декодировать. К сожалению, официального описания формата я не нашёл. Зато нашёл вполне [работающий декодер на GitHub](https://github.com/radio-satellites/RoseyCubesat-1-tools/tree/main). Пакеты с камеры имеют тип 0xA40C и отлично встраиваются в уже существующий декодер: [RoseyCubesatBeacon](https://github.com/dernasherbrezon/jradio/blob/9c51c5113ff2c719eb480ddf5df12e9c2fad0404/src/main/java/ru/r2cloud/jradio/roseycub/RoseyCubesatBeacon.java#L9).

Каждый пакет со спутника содержит:

<table>
	<thead>
	<tr>
		<th style="width: 20%">Название</th>
		<th style="width: 20%">Размер (байт)</th>
		<th>Описание</th>
	</tr>
	</thead>
	<tbody>
		<tr>
			<td>sequenceId</td>
			<td>2</td>
			<td>Всегда 0. Можно игнорировать</td>
		</tr>
		<tr>
			<td>isPreview</td>
			<td>1</td>
			<td>Позволяет понять изображение - это небольшое превью размером 48х36 или полноценное - 480х360</td>
		</tr>
		<tr>
			<td>elementId</td>
			<td>2</td>
			<td>Порядковый номер пакета в изображении</td>
		</tr>
		<tr>
			<td>data</td>
			<td>80</td>
			<td>Массив байт с данными изображения. Каждый байт - это пиксель</td>
		</tr>
	</tbody>
</table>

Конечно, протокол не такой совершенный, как [ssdv]({{< ref "/decoding-jy1sat" >}}), но он и не настолько примитивный, как в [1kuns-pf]({{< ref "/restore-jpeg-file" >}}). Благодаря передаче пикселей "как есть", возможно восстановление изображения, даже если потеряно один или несколько пакетов. Это особенно важно для кубсатов со слабым сигналом.

Если получить несколько пакетов, отсортировать по порядковому номеру, то получится вполне неплохой результат:

![](/img/bayer-filter/1.png)

Однако, если присмотреться поближе, то можно увидеть странные артефакты:

![](/img/bayer-filter/2.png)

Так выглядит результат работы [фильтра Байера](https://ru.wikipedia.org/wiki/Фильтр_Байера). 

## Фильтр Байера

Фильтр Байера используется для того, чтобы уменьшить размер изображения, не сильно ухудшая его восприятие. Идея заключается в том, что для каждого пикселя можно передавать не 3 байта (RGB), а только один определённого цвета. Какой именно цвет передавать зависит от специального шаблона. Изображение разделяется на небольшие области 2х2 пиксела. Далее в зависимости от положения пиксела и выбранного шаблона выбирается нужный цвет. Бывает 4 шаблона:

{{< svg "/img/bayer-filter/bayer.svg" >}}

Вопрос со звёздочкой: Почему зелёного в два раза больше, чем красного и синего? 

Если восстановить цвет согласно положению пиксела в шаблоне, то получится следующее:

![](/img/bayer-filter/3.png)

Значительно лучше! Можно отчётливо видеть разные цвета и переходы. Изображение явно не чёрно-белое. При увеличении видно, что пикселы просто раскрашены согласно шаблону с разной интенсивностью:

![](/img/bayer-filter/4.png)

Следующим этапом будет интерполяция цветов. Вместо того, чтобы брать только зелёный согласно шаблону, можно посчитать значение красного и синего для этого же пиксела как среднее между соседними пикселами этого же цвета. Например, для шаблона BGGR:

{{< svg "/img/bayer-filter/demosaic.svg" >}}

Если применить интерполяцию, то получится отличный результат:

![](/img/bayer-filter/5.png)

Кстати, если попробовать другой шаблон, то всё изображение приобретёт другой оттенок.

![](/img/bayer-filter/6.png)

## Высококачественная интерполяция

[Группа исследователей](https://stanford.edu/class/ee367/reading/Demosaicing_ICASSP04.pdf) предположила, что интенсивность каждого пиксела может зависить не только от соседних пикселов того же цвета, но и от цвета других пикселей. И в качестве региона для интерполяции  предложила использовать область 5х5 пикселей. Помимо этого каждый пиксель нужно брать с определённым коэффициентом.

{{< svg "/img/bayer-filter/hq.svg" >}}

То ли лыжи не едут, то ли я неправильно что-то закодил, но разницы особо не видно.

{{<compare id="hqCompare" before="/img/bayer-filter/5.png" after="/img/bayer-filter/7.png" >}}

В итоге я решил остановится на простой интерполяции, так как она даёт более гладкий градиент между соседними пикселами.

## Результат

[Декодер изображения](https://github.com/dernasherbrezon/jradio/blob/9c51c5113ff2c719eb480ddf5df12e9c2fad0404/src/main/java/ru/r2cloud/jradio/roseycub/RoseyPictureDecoder.java) получился достаточно простой, без лишних зависимостей вроде OpenCV и делает то, что надо. Из того, что можно улучшить и добавить:

 * альфа-канал. Пропущенные пакеты неплохо было бы делать прозрачными
 * протестировать на превью-изображениях. Я долго искал подобные изображения в данных из Satnogs, но ничего не нашёл
