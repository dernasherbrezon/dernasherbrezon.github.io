---
title: "Программирование ESP32"
date: 2021-12-30T11:30:18+00:00
draft: false
tags:
  - esp32
  - lora
  - r2lora
---
В последнее время всё популярнее становится протокол передачи данных [LoRa](https://ru.wikipedia.org/wiki/LoRa). Уже несколько спутников вовсю его используют и существует целая сеть приёма сигналов - [tinyGS](https://tinygs.com). Конечно же, пропустить такое я не мог и начал исследовать как подключить протокол LoRa к [r2cloud](https://github.com/dernasherbrezon/r2cloud). К сожалению, это закрытый протокол, поэтому демодулировать его стандартным rtl-sdr не получится. Для получения сигнала нужно использовать специальный чип, который на выходе уже выдаст готовый пакет. Эти чипы достаточно дешёвые, но напрямую к Raspberrypi не подключаются, а используются в основном в связке с ESP32. Из всего этого и родился мой новый проект - [r2lora](https://github.com/dernasherbrezon/r2lora).

## Постановка задачи

Итак, нужно дать доступ к чипу LoRa из r2cloud. Желательно, чтобы интерфейс доступа был универсальный и подходил не только для проекта r2cloud. Это позволит другим проектам, не связанным с приёмом спутниковых сигналов, использовать проект, улучшать и вносить изменения.

Есть несколько вариантов:

 * Полностью реализовать функционал r2cloud на ESP32. Сюда входит: составление расписания пролётов, получение параметров спутников, авто-обновление, отправка на центральный сервер. Это достаточно трудоёмкий процесс - ведь придётся переписать очень много уже готового и оттестированного кода. Опять же, непонятно хватит ли мощности ESP32 для расчёта орбит спутников.
 * Написать минимальное приложение для управления чипом и контролировать приём сигнала из r2cloud.
 
Я решил пойти вторым путём. Во-первых, в r2cloud уже есть поддержка получения данных из внешних источников (plutosdr и sdr-server). Поэтому для добавления LoRa будет достаточно написать ещё один модуль. Во-вторых, логики на ESP32 будет минимальное количество. Чем меньше кода, тем меньше ошибок. В-третьих, такой дизайн позволит переиспользовать проект не только для приёма сигналов со спутников.

## Дизайн

В общем виде дизайн r2lora выглядит следующим образом:

![](/img/programming-esp32/design.png)

Клиенты взаимодействуют с сервисом с помощью REST API, в котором доступно несколько методов:

 * начать получение данных
 * получить все принятые пакеты данных. Нужно запускать периодически для скачивания принятых пакетов.
 * окончить получение данных
 * передать данные
 * получить статус приложения

Я выбрал именно поллинг данных вместо вебсокетов, так как его наиболее просто реализовать на ESP32. А также потому, что он очень надёжный. При использовании вебсокетов пришлось бы реализовывать алгоритмы переподключения и дедубликации данных.

Помимо основного функционала, необходимо реализовать вспомогательный. Компонент "Configurator" предназначен для того, чтобы создать начальную конфигурацию устройства. Он работает следующим образом:
 
 * Если устройство ещё не сконфигурировано, то необходимо поднять собственную точку доступа.
 * Для того, чтобы выполнить начальную конфигурацию, пользователь должен подключится к этой точке доступа, настроить логин, пароль к локальной WiFi точке доступа.
 * Отсоединится
 * После чего, устройство отключит собственную точку доступа и попытается подключиться к локальной
 * Если подключение удалось, то приложение стартует WebServer и начинает слушать команды от пользователя

Если устройство уже сконфигурировано, то оно сразу должно подключатся к локальной точке доступа. Если же подключение не удалось, то оно должно возвращаться в начальное состояние и поднимать собственную точку.

Ещё одним обязательным компонентом является [Firmware-Over-The-Air (FOTA)](https://ru.wikipedia.org/wiki/Обновление_по_воздуху). Все приложения содержат ошибки, одним из способов уменьшения их влияния является автообновление. FOTA позволяет автоматически скачивать прошивку с центрального сервера и обновлять устройство.

## Выбор инструментов

Для разработки под ESP32 есть несколько инструментов: [Arduino IDE](https://www.arduino.cc/en/software), [PlatformIO](https://platformio.org) и [ESP-IDF](https://github.com/espressif/esp-idf). На самом деле стандартом де-факто постепенно стал PlatformIO. Он позволяет не только разрабатывать проект на C/C++, но и собирать проект, управлять сторонними библиотеками, запускать тесты, анализировать код и многое другое.

PlatformIO - это просто плагин к Visual Studio Code. Для установки достаточно скачать VSCode и установить плагин.

![](/img/programming-esp32/platformio.png)

Помимо IDE, PlatformIO предоставляет CLI. С помощью него можно делать всё то же самое, что и в IDE, но в консоли. Дизайн PlatformIO очень похож на cmake, который лишь вызывает gcc с нужными параметрами, генерирует makefile, собирает приложение и пр. PlatformIO скачивает многочисленные Python-зависимости и делегирует сборку тому же ESP-IDF. При этом он отлично интегрирует множество несвязанных инструментов между собой позволяя сосредоточится на разработке приложения, а не конфигурировании.

На самом деле PlatformIO покрывает 100% всех потребностей. За несколько месяцев разработки я не испытывал никаких неудобств и всё было под рукой.

В следующей статье я постараюсь описать структуру проекта, процесс разработки приложения и раскрыть некоторые особенности программирования под микроконтроллеры.
 