<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Testing on dernasherbrezon</title>
    <link>https://dernasherbrezon.com/tags/testing/</link>
    <description>Recent content in Testing on dernasherbrezon</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru</language>
    <lastBuildDate>Thu, 23 Sep 2021 21:20:18 +0100</lastBuildDate>
    <atom:link href="https://dernasherbrezon.com/tags/testing/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Сравнение различных флагов компиляции для Raspberrypi</title>
      <link>https://dernasherbrezon.com/posts/compare-compile-flags-raspberrypi/</link>
      <pubDate>Thu, 23 Sep 2021 21:20:18 +0100</pubDate>
      <guid>https://dernasherbrezon.com/posts/compare-compile-flags-raspberrypi/</guid>
      <description>Недавно мне на глаза попалась самая первая версия Raspberry pi и я решил немного поэкспериментировать со старым железом.&#xA;Мне было интересно насколько отличается производительность библиотеки volk в зависимости от различных флагов компиляции.&#xA;arm1176jzf-s Для начала необходимо определиться с процессором. Как известно, Raspberrypi использует system-on-the-chip (SoC) от broadcom. Это даже написано на самом процессоре: Broadcom BCM2835. Внутри этого чипа находится несколько логических компонентов:&#xA;ядро CPU - ARM arm1176jzf-s ядро GPU - VideoCore 4 К сожалению, стандартные linux инструменты выдают совершенно неправильную информацию о процессоре, поэтому приходится смотреть маркировку прямо на плате и искать информацию в Интернете.</description>
    </item>
    <item>
      <title>Передача сигнала с помощью plutosdr</title>
      <link>https://dernasherbrezon.com/posts/plutosdr-tx/</link>
      <pubDate>Fri, 25 Jun 2021 10:58:18 +0100</pubDate>
      <guid>https://dernasherbrezon.com/posts/plutosdr-tx/</guid>
      <description>Последние несколько месяцев я напряжённо работаю над своим проектом sdr-modem. Он представляет собой небольшой TCP сервер, который получает массив байт от клиента и передаёт их с помощью радио сигнала в эфир. Также он может и получать сигнал, декодировать и отправлять клиентам поток байтов.&#xA;Пару недель назад я наконец-то дописал основную функциональность и тесты. Пришло время протестировать его работу в реальных условиях. Для этого я сделал небольшой тестовый стенд:&#xA;java приложение соединяется с sdr-modem по TCP и отправляет массив байтов.</description>
    </item>
    <item>
      <title>Юнит-тесты</title>
      <link>https://dernasherbrezon.com/posts/unit-tests/</link>
      <pubDate>Mon, 25 May 2020 17:27:18 +0100</pubDate>
      <guid>https://dernasherbrezon.com/posts/unit-tests/</guid>
      <description>15 лет назад никто не слышал про юнит-тесты. Код писался один раз, потом проверялся вручную QA и методами пристального вглядывания. Все жили в гармонии и мире. Но тут пришли юнит-тесты и мир разделился на два враждующих лагеря: на тех, кто пишет тесты и тех, кто нет.&#xA;Спойлер: я за авто-тесты.&#xA;В интернете очень много аргументов как за, так и против. Я решил собрать свой собственный список аргументов за юнит-тесты.&#xA;1 Тесты пишутся не для того, чтобы протестировать каждое логическое условие и всевозможные комбинации входных и выходных данных.</description>
    </item>
  </channel>
</rss>
