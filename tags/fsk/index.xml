<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>fsk on dernasherbrezon</title>
    <link>https://dernasherbrezon.com/tags/fsk/</link>
    <description>Recent content in fsk on dernasherbrezon</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru</language>
    <lastBuildDate>Tue, 15 Mar 2022 19:48:18 +0000</lastBuildDate>
    <atom:link href="https://dernasherbrezon.com/tags/fsk/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Оптимизация приёма AX.25</title>
      <link>https://dernasherbrezon.com/posts/ber-ax25-optimization/</link>
      <pubDate>Tue, 15 Mar 2022 19:48:18 +0000</pubDate>
      <guid>https://dernasherbrezon.com/posts/ber-ax25-optimization/</guid>
      <description>Введение Итак, после того, как измерена BER кривая для AX.25 декодера, можно попробовать её оптимизировать.&#xA;Оптимизация заранее известного заголовка Просмотрев несколько десятков протоколов различных спутников от UNISAT-7 до FIREBIRD 4, я обнаружил, что они всегда шлют один и тот же AX.25 заголовок. Заранее зная такой заголовок, можно игнорировать его в принятом фрейме и попытаться исправить ошибки получения. Алгоритм тогда будет выглядеть следующим образом:&#xA;найти флаги начала и окончания HDLC фрейма посчитать контрольную сумму если сумма совпала, то фрейм корректно получен если сумма не совпала, то подставить заранее известный заголовок в начало фрейма посчитать контрольную сумму ещё раз если сумма совпала, то фрейм удалось восстановить если не совпала, то ничего не поделаешь - фрейм утерян При таком алгоритме спутник может слать как известные заголовки, так и нет.</description>
    </item>
    <item>
      <title>Расчёт вероятности ошибки для AX.25</title>
      <link>https://dernasherbrezon.com/posts/ber-ax25/</link>
      <pubDate>Sat, 19 Feb 2022 22:13:18 +0000</pubDate>
      <guid>https://dernasherbrezon.com/posts/ber-ax25/</guid>
      <description>Введение Обычно вероятность ошибки используется для сравнения различных типов модуляции между собой. Однако, на практике помимо демодулятора используются дополнительные блоки:&#xA;формирование фреймов канального уровня контроль и коррекция ошибок И каждый из этих блоков может как уменьшить вероятность декодирования фрейма, так и увеличить. Все алгоритмы контроля и коррекции ошибок предназначены для того, чтобы увеличить вероятность декодирования фрейма. А вот формирование самих фреймов может сильно повлиять на возможности получения данных.&#xA;Одним из самых распространённых протоколов канального уровня является HDLC.</description>
    </item>
    <item>
      <title>Оптимизация FSK демодулятора</title>
      <link>https://dernasherbrezon.com/posts/tune-ber-fsk/</link>
      <pubDate>Mon, 03 Aug 2020 20:22:18 +0100</pubDate>
      <guid>https://dernasherbrezon.com/posts/tune-ber-fsk/</guid>
      <description>Не прошло и года, а я уже придумал как улучшить свой FSK демодулятор. Как уже писал, имея на руках BER кривую, можно начинать улучшать демодулятор. Первым делом я сравнил FSK демодулятор SatNOGS и свой.&#xA;Для этого я взял сырые данные (.wav файл) из обработанного пролёта спутника и попробовал прогнать его через свой демодулятор. В результате у меня получилось 23 пакета. Однако, демодулятор SatNOGS смог найти 24 пакета.&#xA;Всё это значит, что есть пространство для оптимизации.</description>
    </item>
    <item>
      <title>Расчёт вероятности ошибки для FSK демодулятора</title>
      <link>https://dernasherbrezon.com/posts/jradio-ber-fsk/</link>
      <pubDate>Sat, 01 Aug 2020 10:22:18 +0100</pubDate>
      <guid>https://dernasherbrezon.com/posts/jradio-ber-fsk/</guid>
      <description>Введение Прошёл почти год с того момента, когда я измерял BER для BPSK демодулятора. И вот пришло время измерить вероятность ошибки для FSK демодулятора. Поводом к такому исследованию послужило большое количество спутников, передающих частотно-модулированный сигнал. Мне хотелось прежде всего измерить текущие характеристики демодулятора, чтобы в последствии можно было его улучшать.&#xA;Описание теста С прошлого раза я решил существенно поменять методологию. Раньше для подсчёта ошибок использовалось скремблирование. Все полученные нулевые биты делились на 6, из-за характеристик полинома скремблера и дифференциального кодирования.</description>
    </item>
  </channel>
</rss>
